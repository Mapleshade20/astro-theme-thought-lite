---
import type { MarkdownHeading } from "astro";
import { i18n } from "astro:config/client";
import config, { monolocale } from "$config";
import { getCollection, render } from "astro:content";
import Time from "$utils/time";
import Base from "$layouts/Base.astro";
import Icon from "$components/Icon.astro";
import TOC from "$components/TOC.astro";
import Position from "$components/Position.astro";
import Sensitive from "$components/Sensitive.svelte";
import i18nit from "$i18n";
import { Image } from "astro:assets";
import VerCountLoader from "$components/VerCountLoader.astro";

export async function getStaticPaths() {
	// Get all knowledge items excluding drafts
	const knowledge = await getCollection("knowledge", item => !item.data.draft);

	return knowledge.map(item => {
		let locale: string | undefined;
		let id: string;
		if (monolocale) {
			locale = undefined;
			id = item.id;
		} else {
			// Extract language and item ID from file path structure
			const [language, ...ids] = item.id.split("/");

			locale = config.i18n.defaultLocale === language ? undefined : language;
			id = ids.join("/");
		}

		// Generate path params with optional locale (omit for default locale)
		return { params: { locale, id }, props: { item } };
	});
}

const { locale = i18n!.defaultLocale } = Astro.params;
const { item } = Astro.props;

// Render markdown content and extract headings for TOC
const { Content, headings, remarkPluginFrontmatter: frontmatter } = await render(item);

// Build hierarchical table of contents from flat heading list
type Heading = MarkdownHeading & { subheadings: Heading[] };
const tableOfContents: Heading[] = [];
const stack: Heading[] = [];
for (const headingItem of headings) {
	// Pop headings from stack that are at same or deeper level
	while (stack[stack.length - 1]?.depth >= headingItem.depth) stack.pop();
	const heading: Heading = { ...headingItem, subheadings: [] };

	if (stack.length > 0) {
		// Add as subheading to current parent
		const parent = stack[stack.length - 1];
		parent.subheadings.push(heading);
	} else {
		// Add as top-level heading
		tableOfContents.push(heading);
	}

	stack.push(heading);
}

const t = i18nit(locale);

// Calculate progress percentage from totalPages and currentPage
const progress = item.data.totalPages && item.data.totalPages > 0 ? Math.round((item.data.currentPage / item.data.totalPages) * 100) : 0;

const coverImage = item.data.cover;

// Status label
const statusLabel = {
	todo: t("library.status.todo"),
	inProgress: t("library.status.inProgress"),
	done: t("library.status.done")
};
---

<Base title={item.data.title} {locale} description={item.data.description} article={item.data.dates?.start ? { timestamp: item.data.dates.start, tags: item.data.tags } : undefined}>
	<VerCountLoader slot="head" />
	<main class="flex flex-col gap-6">
		<header class="block flow-root">
			{
				coverImage && (
					<div class="float-right w-auto max-w-[15%] ml-4 mb-2">
						<Image src={coverImage} alt={item.data.title} class="rounded-lg shadow-md object-cover w-full h-auto" width={200} inferSize densities={[1.5, 2]} />
					</div>
				)
			}

			<div class="flex flex-col gap-2 mb-4">
				<h1 class="text-3xl">{item.data.title}</h1>
				{item.data.author && <p class="text-base c-remark">{item.data.author}</p>}
			</div>

			<div class="flex flex-col gap-3 sm:flex-row sm:flex-wrap children:(flex items-center gap-1 text-sm c-remark) mb-4">
				<span>
					<Icon name="lucide:activity" />
					{statusLabel[item.data.status]}
					{progress > 0 && `(${progress}%)`}
				</span>
				{
					item.data.dates?.start && (
						<time title={Time.date.locale(item.data.dates.start, locale)}>
							<Icon name="lucide:calendar-arrow-down" />
							{t("library.dates.startedOn")} {Time.date.locale(item.data.dates.start, locale)}
						</time>
					)
				}
				{
					item.data.dates?.finish && (
						<time title={Time.date.locale(item.data.dates.finish, locale)}>
							<Icon name="lucide:calendar-check" />
							{t("library.dates.finishedOn")} {Time.date.locale(item.data.dates.finish, locale)}
						</time>
					)
				}
				{
					frontmatter.words && (
						<span>
							<Icon name="lucide:pilcrow" />
							{t("read.words", { words: frontmatter.words })}
						</span>
					)
				}
				<span><Icon name="lucide:eye" /><Fragment set:html={t("read.views", { views: `<span id="vercount_value_page_pv">-</span>` })} /></span>
				{
					item.data.dates?.lastEdited &&
						(() => {
							const agoData = Time.ago(item.data.dates.lastEdited);
							const agoTranslations = {
								year: t("library.dates.ago.year", { count: "{{count}}" }),
								years: t("library.dates.ago.years", { count: "{{count}}" }),
								month: t("library.dates.ago.month", { count: "{{count}}" }),
								months: t("library.dates.ago.months", { count: "{{count}}" }),
								day: t("library.dates.ago.day", { count: "{{count}}" }),
								days: t("library.dates.ago.days", { count: "{{count}}" }),
								today: t("library.dates.ago.today", { count: "{{count}}" }),
							};
							return (
								<>
									<time
										data-last-edited={item.data.dates.lastEdited.toISOString()}
										data-ago-translations={JSON.stringify(agoTranslations)}
										title={Time.date.locale(item.data.dates.lastEdited, locale)}
									>
										<Icon name="lucide:clock" />
										{t("library.dates.lastEdited")}{" "}
										<span class="ago-text">{t(`library.dates.ago.${agoData.unit}`, { count: agoData.count })}</span>
									</time>
									<script>
										import Time from "$utils/time";
										const timeElement = document.querySelector<HTMLElement>("time[data-last-edited]");
										if (timeElement) {
											const lastEdited = timeElement.dataset.lastEdited;
											const translations = JSON.parse(timeElement.dataset.agoTranslations || "{}");
											if (lastEdited && translations) {
												const agoData = Time.ago(new Date(lastEdited));
												const template = translations[agoData.unit];
												if (template) {
													const text = template.replace("{{count}}", agoData.count);
													const span = timeElement.querySelector(".ago-text");
													if (span) span.textContent = text;
												}
											}
										}
									</script>
								</>
							);
						})()
				}
			</div>

			{item.data.description && <p class="text-base c-remark border-l-2 border-l-solid border-l-primary pl-3 mb-4">{item.data.description}</p>}

			<hr class="b-b b-b-solid b-weak clear-both" />
		</header>
		<Sensitive {locale} back="/library" sensitive={item.data.sensitive} client:load>
			<div class="flex gap-5">
				<section id="markdown-content" class="markdown"><Content /></section>
				{
					item.data.toc && (
						<aside class="hidden sm:(block flex-shrink-0 w-200px)">
							<div class="sticky top-3 flex flex-col gap-2">
								<h3>{t("note.contents")}</h3>
								<nav class="overflow-y-auto">
									<TOC headings={tableOfContents} />
								</nav>
							</div>
						</aside>
					)
				}
			</div>
		</Sensitive>

		{
			!!item.data.tags?.length && (
				<footer class="flex items-center gap-1 text-xs c-weak">
					<Icon name="lucide:tag" />
					{item.data.tags?.join("; ")}
				</footer>
			)
		}

		<Position {locale} />
	</main>
</Base>
