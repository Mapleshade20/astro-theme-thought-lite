---
import { getCollection } from "astro:content";
import config, { monolocale } from "$config";
import Base from "$layouts/Base.astro";
import Note from "$components/Note.svelte";
import Icon from "$components/Icon.astro";
import i18nit from "$i18n";

export async function getStaticPaths() {
	// Create path for each locale, omitting default locale from URL
	return config.i18n.locales.map(locale => ({ params: { locale: config.i18n.defaultLocale === locale ? undefined : locale } }));
}

const { locale = config.i18n.defaultLocale } = Astro.params;

const t = i18nit(locale);

const notes = await getCollection("note", note => {
	// Filter by publication status and locale
	let published = !note.data.draft;
	let localed = monolocale || note.id.split("/")[0] === locale;

	return published && localed;
});

// Fetch knowledge items that should appear in note feed
const knowledge = await getCollection("knowledge", item => {
	// Extract language from the file path structure
	const [language] = item.id.split("/");

	// Filter criteria: must be published, match locale, and have showAsNote enabled
	let published = !item.data.draft;
	let localed = language === locale;
	let showAsNote = item.data.showAsNote;

	return published && localed && showAsNote;
});

// Standardize note structure
let list: Array<{
	id: string;
	type: string;
	data: {
		title: string;
		timestamp: Date | undefined;
		series?: string;
		tags?: string[];
		sensitive: boolean;
		top: number;
		status?: string;
		knowledgeType?: string;
	};
}> = notes.map(note => ({
	id: note.id,
	type: "note",
	data: {
		title: note.data.title,
		timestamp: note.data.timestamp,
		series: note.data.series,
		tags: note.data.tags,
		sensitive: note.data.sensitive,
		top: note.data.top
	}
}));

// Transform knowledge items to note-compatible structure
const knowledgeItems = knowledge
	.map(item => {
		// Determine latest date for sorting (lastEdited > finish > start)
		const latestDate = item.data.dates?.lastEdited || item.data.dates?.finish || item.data.dates?.start;

		return {
			id: item.id,
			type: "knowledge",
			data: {
				title: item.data.title,
				timestamp: latestDate,
				series: undefined, // Knowledge items don't have series
				tags: item.data.tags,
				sensitive: item.data.sensitive,
				top: 0, // Knowledge items are not pinned
				status: item.data.status, // Include status for badge display
				knowledgeType: item.data.type // Include type (book/video/course)
			}
		};
	})
	.filter(item => item.data.timestamp); // Only include items with a valid date

// Merge notes and knowledge items
list = [...list, ...knowledgeItems];

// Extract all unique series and tags from the filtered notes and knowledge items
const series = Array.from(new Set(notes.map(note => note.data.series).filter(Boolean))).sort();
const tags = Array.from(
	new Set([...notes.flatMap(note => note.data.tags).filter(Boolean), ...knowledge.flatMap(item => item.data.tags).filter(Boolean)])
).sort();
---

<Base title={t("navigation.note")} {locale}>
	<main class="flex flex-col grow">
		<Note client:load {locale} notes={list} {series} {tags}>
			<Icon name="lucide:flag-triangle-right" slot="top" />
			<Icon name="lucide:siren" title={t("sensitive.icon")} slot="sensitive" />
			<Icon name="lucide:arrow-left" slot="left" />
			<Icon name="lucide:arrow-right" slot="right" />
			<Icon name="lucide:ellipsis" slot="dots" />
		</Note>
	</main>
</Base>
